Глава 19 Страуструпа
В проекте рассматриваются итераторы:
обычные, инсертеры, обратные итераторы, итераторы потоков.
Распределители памяти, стандартные и определяемые пользователем.

Вопросы:

Сделать:
1. примеры с файловыми итераторами - вывод каждой третьей строки, ввод двух строк и т.п.

Советы и резюме:
* Выражайте алгоритмы при помощи концепции итераторов.
* Для выражения алгоримов, использующих разные типы итераторов, используйте iterator_traits
 (там хранятся типы, связанные с этим итератором - diff, ref и т.п.)
* В алгоритмах также неявно передается объект "категории итератора"
* Используйте inserter для вставки в контейнеры при помощи алгоритмов 
 (за исключением, когда выходная последовательность совпадает с входной)
* Предпочитайте форму ++it
* Работу с памятью можно оптимизировать своим аллокатором.
* И итератор, и распределитель памяти - это чистая абстракция
* У аллокаторов есть стандартный интерфейс, который поддержан Стандартом
* Аллокатор может выделять память не только для элементов контейнера,
  но и для служебных структур (rebind)
* construct/destroy работает с выделенной памятью и вызывает конструкторы в ней
* allocate/deallocate инициализируют "сырую" память
* У деаллокации по умолчанию нет проверки на 0
* Можно заставить распределитель хранить (и предоставлять)
  некие служебные данные (где хранятся объекты, контроль контейнеров и тп)
* в аллокаторе обязательно должна быть приведена специализация для void
* шаблонный оператор == сообщает, что все специализации взаимозаменяемы
  это значит, что память можно выделить одним, а уничтожить другим
* В STL входят функции для низкоуровневой работы с 
  пользовательскими контейнерами и алгоритмами (uninitialized_*)
* Функции ANSI C для управления сырой памятью лучше не применять 
  или применять на очень низком уровне