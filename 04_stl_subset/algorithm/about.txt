Глава 18 Страуструпа
В проекте рассматриваются алгоритмы, функторы, адаптеры и биндеры.

Вопросы:

Сделать:

Советы и резюме:
1. Нет смысла включать в программу все алгоритмы или более сложные алгоритмы.
2. Алгоритмы - это шаблоны, принимающие последовтельности в виде иераторов.
3. О неудаче поиска сообщает как правило итератор конца последовательности.
4. Алгоритмы не выполняют проверки диапазона на входе и выходе.
5. Большинство алгоритмов дает возможность программисту определить операцию сравнения или преобразования.
6. Операции с кучей поддерживают последовательность в состоянии, облегчающем сортировку.
7. Большинство алгоритмов объявлено в <algorithm>, несколько - в <numeric>
8. Предпочитайте алгоритмы циклам. Преобразуйте циклы в алгоритмы.
9. Для применения алгоритмов к контейнерам пользуйтесь mem_fun и ptr_fun
10.Пользуйтесь for_each и transform только когда для задачи нет более специфичного алгоритма.
11.Регулярно пересматривайте набор алгоритмов.
12.Пользуйтесь связывателями.
13.operator() в функторе можно перегружать.
14.Модифицирующие алгоритмы не изменяют количество элементов в контейнере.
15.Пользуйтесь сортированными последовательностями.
16.Пользуйтесь ANSI C алгоритмами только для совместимости.
17.STL предоставляет базовые классы для функторов: unary_function & binary_function
18.Обязательно наследовать от binary_function или unary_function.
19.Предикатом может быть все, к чему применяется операция ().
20.for_each() - немодифицирующий алгоритм!
21.Модифицирующие алгоритмы необязательно пишут изменения во входную последовательность.
22.Использование вставок (inserter) не позволяет выйти за пределы контейнера 
   и позволяет удобно записывать в конец.
23.Входная и выходная последовательности могут перекрываться.
24.Для облегчения передачи последовательности в алгоритм 
   можно определить тип последовательности (пара итераторов, определяющих контейнер).
* Алгороитмы могут возвращать разные типы, какие - описано в iterator_traits
* Const ref makes rvalue object live the same time as ref
* Non-const pointer is assigned to const (not otherwise!)
