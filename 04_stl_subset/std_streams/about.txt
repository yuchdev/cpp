Глава 21 Страуструпа
Потоки вывода - встроенные типы, типы, определяемые пользователем.
Потоки вывода - встроенные и пользовательские типы, ввод символов, 
состояние потока, часовые, исключение, связывание потока.
Форматирование, состояние формата, вывод чисел, выравнивание, манипуляторы.
Файловые потоки. Буферизация. Локализация.

Вопросы:

Сделать:

Советы и резюме:
* ostream could be considered as a convertation object->symbols. istream is vise versa
* streams use char_traits in internals
* basic_ios controls formatting, locales and buffer management
* istream-ostream could not be copied!
* ostream could be "virtualized" passing to the operator << a reference to the base class
* input stream could be converted to void* that is used for end-of-input sign: while(is >> buf)
* <iosfwd> is used for the forward declaration if all IO templates
* error streams are cerr(non-buffered), clog (buffered)
* all integer types out as-is
* floating precision = 6 by default, E form if neccessary
* bool is out as 1/0
* pointers out as hex
* flags or manipulators could be used to change formatting
* cout.put/write could be used for output as well
* >> << priority is low
* Enter is end-of-input
* whitespace is delimeter by defaut (switch off using noskipws())
* put/write opposite is get/read
* after cin.get() or wcin >> cin.ignore() should be called to skip \n
* cout-cin could be 'tied' using tie() method to be used in pair
* in case of custom delimeters (i.e. cin.get(s1, 50, '.')) '.' should be ignored as well
* std::getline() ignores \n automatically
* stream error flags: eof, fail (recoverable error), bad (fatal error)
* after fail stream could be recovered using cin.clear(/*ios_base::goodbit*/)
* cin.rdstate() reads flags
* cin.exceptions(ios::badbit|ios::failbit) sets thowing exceptions insted of flags setting
* every buffered stream have his own buffer. It could be accessed: f.rdbuf()
* buffer could be used for the stream redirection
* with non-latin wide symbols locale should be set (imbue() method)
* file streams are RAII wrappers under files
* text filestreams are formatted, binary - don't
* filestreams are buffered
* while random write access ios::in must be set!
* stringstream allocates std::string using new()
* setting flags:
-flags() = analog
-setf() OR analog
-unsetf() NOR analog
* stream format could be copied by copyfmt() method
* precision() sets count of numbers ofter the point. Works constantly
* fill() sets fill symbol. Works constantly
* width() sets input fiels width. Works for the one input operation.
* user manipulator without params could be easily created
* user manipulator with params called effector as a class 
  with one param constructor ostream << operator overload
  Could be used for complicated formatting (dates, currencies, etc)

