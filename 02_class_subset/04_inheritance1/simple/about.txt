Глава 12 Страуструпа
Глава 9 Лаптева
Мейерс 1 Глава 6 (Наследование)
Производные классы. Иерархия классов. 
Наследование реализации.
Виртуальные функции. Абстрактные классы. 
Проектирование иерархий классов.


Вопросы


Сделать:


// Абстрактные классы широко применяются в паттернах проектирования и технологии COM.

// Принцип подстановки Лисков:
// Основная идея такова: функция, использующая ссылку или указатель на базовый класс 
// должна уметь работать и с классами-наследниками, без их распознавания.
// http://forums.realcoding.net/index.php?showtopic=16693


Консистентность, в данном случае, означает соответствие значений всех переменных объекта его состоянию. 
Например, объект-строка имеет две переменные: указатель блока памяти и длину строки. 
Присваивая объекту более длинную строку, мы должны освободить старый блок памяти, выделить новый, 
скопировать строку, изменить значение указателя и значение длины. Перед выполнением первой 
из этих операций, данные объекта консистентны, после выполнения последней — тоже. 
Между первой и последней операциями, консистентность нарушена.

Правило 1: При возврате из любого public метода, данные объекта должны быть консистентны.
Правило 2: Перед выполнением исходящего вызова следует обеспечить консистентность данных объекта.
Правило 3: Необходимо учитывать, что, за время исходящего вызова, состояние объекта может быть изменено.


Советы:
1. Не используйте поля хранящие информацию о типе.
2. Не передавайте объекты по значению во избежание срезки.
3. Переопределяйте конструктор повышающего преобразования для того же 
    (явно вызывая метод или конструктор родительского класса в функциональной форме).
4. Пользуйтесь абстрактными классами для 
   - определения интерфейса
   - установления контракта
   - реализации по умолчанию (хотя в ряде случаев имеет смысл ее также отделить)
5. В виртуальных классах следует иметь виртуальный деструктор.
6. Абстрактный класс обычно не нуждается в конструкторе
7. Общепринятая практика - наследовать классы от классов (т.е. структуры в наследовании не участвуют)
8. Конструктор не наследуется - он создается по умолчанию или реализуется явно
9. Также не наследуются операторы присваивания и дружественные функции
10.Деструкторы вызываются в порядке, обратном конструктору, и не наследуются
11.Добавляемые поля могут совпадать по имени с полями базового
12.Хотя так делать не рекомендуется (в этом случае базовый член класса замещается производным)
13.В производном списке инициализации нельзя инициализировать члены базовых классов, но можно в теле конструктора
14.Методы базового класса можно вызывать явно.
15.Пользуйтеся закрытым или защищенным наследованием для сокрытия интерфейса базового класса (паттерн Адаптер)
16.Для этого же можно пользоваться агрегированием (композицией)
17.Иерархия классов может быть нециклическим графом. Глубина иерархии ничем не ограничена.
18.В базовом классе необходимо хранить только _самые_ общие данные во избежание дополнительных зависимостей
19.В производных классах виртуальные функции реализуются только если в этом есть необходимость
20.Можно объявить и определить чисто виртуальный деструктор. Он будет нормально вызываться и не наследоваться.
   Т.е. класс-наследник абстрактным не является. (он будет играть роль деструктора по умолчанию)
21.В абстрактном классе можно реализовать не чисто виртуальные методы и вызывать их для производных классов.
22.Можно "виртуализировать" внешние функции (например друзья) путем передачи ссылки 
   на базовый класс с виртуальностью.
23.Можно указывать using::f, чтобы переопределить родительский метод вместо собственного в классе
24.Значения по умолчанию в списке параметров виртуальной функции наследуются и перекрывают вновь определенные!
   Т.е. сами методы связываются динамически, а параметры - статически (они не хранятся в vtbl!)
25.Возвращаемое значение виртуальной функции в разных классах может отличаться, если это:
  - указатель или ссылка
  - они приводятся друг к другу
  (so-called co-variant type)
26. Операторы могут быть виртуальными.
27. Формат VTBL определяется ABI.
28. В конструкторе или деструкторе вызываются только свои виртуальные методы.
29.В случае закрытого наследование также не работает приведение по ссылку-указателю к базовому классу.
30.Для реализации адаптера предпочитайте композицию. Используйте наследование, только когда обязаны так сделать.
   (доступ к защищенным членам, виртуальность)
* Дружественные функции не наследуются
* Better to place constructor-destructor to protected section in abstract classes. 
  That makes classes abstract even WITHOUT pure virtual functions!


In VC++, the vtable pointer stored at the beginning of the object allocation, 
before any member data. (Provided your class has at least one virtual member function.)
There also may be multiple vtable pointers, if your class multiply-inherits from other classes with vtables.
The vtables themselves are statically allocated somewhere in your address space.

Обычно компилятор создает отдельную vtable для каждого класса. 
После создания объекта указатель на эту vtable, называемый виртуальный табличный указатель или vpointer, 
добавляется как скрытый член данного объекта (а зачастую как первый член). 
Компилятор также генерирует «скрытый» код в конструкторе каждого класса 
для инициализации vpointer'ов его объектов адресами соответствующей vtable.

При множественном наследовании в классе содержится несколько vtbl и указателей на виртуальный класс
RTTI тоже содержится в vtbl
ВАЖНО! Схема расположения в памяти данных и vtbl


Мейерс 1

Правило 35 Открытое наследование - в большинстве случаев это отношение "есть разновидность".
При проектировании тщательно выбирайте базовую сущность (классический пример "квадрат-прямоугольник")

Правило 36. Если функция невиртуальная, скорее всего она наследуется всегда и для всех
Если функция чисто виртуальная, наследуется интерфейс.
Если функция чисто виртуального класса определена, наследуется реализация по умолчанию
Если реализация по умолчанию подходит не для всех, необходимо либо выделить иерархию,
либо реализовать невиртуальный метод, вызываемый вручную, типа default(). 
Тогда если переопределенный метод не будет реализован, производный класс не скомпилируется.

Правило 38 - значение аргумента по умолчанию связывается статически, поэтому наследуется

Правило 42 - при закрытом наследовании не только закрывается интерфейс, но и не работает принцип подстановки
Закрытое наследование означает отношение "реализуется посредством"
Выбор между агрегацией и закрытым наследованием: агрегация - если возможно, наследование - если необходимо
(нужно перегрузить виртуальную функцию, нужен доступ к защищенной части)

По умолчанию реализуются: конструктор по умолчанию, копирования, =, деструктор, 
и можно сказать, что операторы * ->
Если определен один конструктор, конструктор по умолчанию не создается
Если определена неконстантная версия копирования (присвоения), константная не создается
Оператор присвоения по умолчанию не работает со ссылками

Мейерс 2

17. Для классов, результаты которорых нужны не всегда или не все, используйте отложенные вычисления
18. Для классов, результаты которых нужны часто, используйте упреждающие вычисления

21. Не делайте объекты виртуальными без надобности. 
inline игнорируется для virtual, но это не ошибка

All cases of pure-virtual function implementation:
1. Pure virtual destructor
2. Implementation by default
3. Common partial implementation (protected)
4. Throw an exception if pure virtual call is possible



