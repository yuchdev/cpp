#pragma once
#include <iostream>
using std::cout;
using namespace std;

// Мейерс 1 Правило 14
// Виртуальные деструкторы! При невиртуальности деструтктора базового класса рез-т не определен.
// Деструкторы можно делать невиртуальными (или вообще не делать) для простых типов
// Объявляйте чисто виртуальные деструкторы, чтобы сделать класс абстрактным
// (при этом потомок не наследует деструктор, следовательно, и абстрактность тоже!)

// Если производный класс перегружает метод – меняется запись в таблице виртуальных функций.
// Если производный класс содержит виртуальные методы, которые не были объявлены в родительском классе –
// они добавляются в конец таблицы.

//Способ хранения указателя и создания таблиц виртуальных функций во многом зависит от компилятора.
//Обычно – таблицы виртуальных функций статические.
//Т.е.они не конструируются при создании каждого экземпляра класса.
//Еще на этапе компиляции доступна вся иерархия полиморфных классов, поэтому компилятор может заранее построить эти таблицы.
//В процессе выполнения конструктор класса просто меняет указатель на свою таблицу.

// Пример с классами без виртуальных функций
// - выполняется только раннее (статическое) связывание
struct Base {
protected:
    int func(int i){ return 2 * i; }

public:

    // из этой функции базового класса вызывается защищенная функция
    // по-разному определенная в базовом и производном классе
    int call_protected_function(int i){ return func(i) + 1; }
};

struct Derived : public Base {
protected:
    // В случае раннего, статического связывания
    // эта функция никогда не будет вызвана
    virtual int func(int i){ return i*i; }
};

struct Base_virt {
protected:
    // Объявим функцию виртуальной. Класс станет полиморфным.
    // Функция и виртуальность станут наследоваться,
    // т.е. все производные классы будут полиморфными.
    virtual int func(int i){ return 2 * i; }

public:
    int call_protected_function(int i){ return func(i) + 1; }
    int call_protected_function_def(int i){ return func(i) + 1; }
};

struct Derived_virt : public Base_virt {
protected:
    // В случае позднего, динамического связывания
    // эта функция будет вызвана для экземпляра класса Derived_virt
    virtual int func(int i){ return i*i; }
};

/*
1. Конструкторы и статические ф-ции не могут быть виртуальными.
2. Прототипы наследуемых виртуальных функций должны совпадать
(за исключением значения, возвращаемого по ссылке или указателю).
3. Если прототип отличается списком параметров, функция теряет виртуальность.
4. Если прототип отличается константностью или возвращаемым значением,
происходит ошибка компиляции.
5. Виртуальную функцию можно вызвать невиртуально, по спецификатору.
6. Затраты на виртуальность - размер указателя, инициализация vtbl и косвенный вызов.
*/

struct A_virt {


    A_virt();
    virtual ~A_virt();

    /**	Выполняем функцию f на создании и разрушении класса
        Функция f виртуальна, следовательно не рекомендована к использованию из
        конструкторов-деструкторов (хотя и не запрещена) */
    virtual ostream& f() const;
    // Наблюдаем, что в конструкторах и деструкторах работает статическое связывание

    //virtual A& operator+=(A_virt& a);
};

/** То же самое для B_virt */
struct B_virt : public A_virt{

    B_virt();
    virtual ~B_virt();
    /**Выполняем функцию f на создании и разрушении класса*/
    virtual ostream& f() const;
};

// Прием искуственной виртуализации внешней функции
// Передаем в нее параметром ссылку на базовый класс
// В резальтате виртуализация работает во внешнней функции
inline ostream& operator<<(ostream& t, A_virt& c){
    return c.f();
}

// Виртуальный деструктор широко используется для полиморфной очистки
// Деструктор может быть чисто виртуальным, но его чистая виртуальность
// отличается от остальных методов (см. пример)

//Чисто виртуальные функции не имеют тела.
//В таблице виртуальных функций они представлены с помощью нулевого указателя.
//Т.е.такая функция не может быть вызвана, точнее может, но это вызовет крах программы.

// При множественном наследовании класс может содержать более 1 vtbl

struct v_base{
    v_base();
    // Создадим чисто виртуальный деструктор
    virtual ~v_base() = 0;
    // чисто виртуальный деструктор может иметь определение!
    // Чисто виртуальный деструктор не наследуется, следовательно,
    // не делает производный класс абстрактным (как и operator=)

    // Более того, чтосто виртуальные методы тоже могут иметь определение
    // и вызываться в производных классах!
    void pure();
    // Это может понадобиться в целях форммирования общего наследуемого кода.
    // Это называется "наследование реализации по умолчанию" (Мейерс)

    // All cases of pure-virtual function implementation:
    // 1. Pure virtual destructor
    // 2. Implementation by default
    // 3. Common partial implementation (protected)
    // 4. Throw an exception if pure virtual call is possible
};

struct v_derived : public v_base {
    v_derived();
    // Не будем реализовать деструктор в производном классе
    // По идее, он должен быть абстрактным
    //~v_derived();
    // Но деструкторы не наследуются, так что абстрактность тоже не наследуется
};


// Еще пара важных моментов:
// При указании в вируальной функции параметра по умолчанию он наследуется
// Тип возвращаемого значения может ОТЛИЧАТЬСЯ, если это указатель или ссылка,
// приводимая к возвращаемомоу значению в базовом (указателю или ссылке)
// so-called co-variant type
struct Base1
{
    // просто виртуальная функция для указания перегрузки
    virtual void f(int) {
        std::cout << "B::f(int)" << std::endl;
    }

    // просто виртуальная функция для указания перегрузки
    virtual void f(double) {
        std::cout << "B::f(double)" << std::endl;
    }

    // виртуальная функция для демонтрации наследования значений по умолчанию
    virtual void g(int i = 10) {
        std::cout << "B::g(int) " << i << std::endl;
    }

    // виртуальная функция для демонтрации различных типов
    // возвращаемых значений
    virtual A_virt* pf(int i = 1){
        std::cout << "A_virt B::pf(int) " << i << std::endl;
        return new A_virt();
    }

    // Changing accessibility of virtual functions!
protected:
    virtual void open_me() const {
        std::cout << "Base1::open_me()" << std::endl;
    }
public:
    virtual void hide_me() const {
        std::cout << "Base1::hide_me()" << std::endl;
    }
};

struct Derived1 : Base1
{
    //int f(int) {
    //	std::cout << "int Derived1::f()" << std::endl;
    //	return 1;
    //}

    // виртуальная функция для демонтрации наследования значений по умолчанию
    // (i = 20) перекрывается (i = 10) из базового
    void g(int i = 20) {
        std::cout << "D::g(int) " << i << std::endl;
    }

    // виртуальная функция для демонтрации различных типов
    // возвращаемых значений (возвращаемый указатель B_virt приводится к A_virt)
    virtual B_virt* pf(int i = 2){
        std::cout << "B_virt* B::pf(int) " << i << std::endl;
        return new B_virt();
    }

public:
    virtual void open_me() const {
        std::cout << "Derived1::open_me()" << std::endl;
    }

protected:
    // this function could be called by the pointer to the base class!
    virtual void hide_me() const {
        std::cout << "Derived1::hide_me()" << std::endl;
    }
};
