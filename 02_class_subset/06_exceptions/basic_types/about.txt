Глава 14, приложение Д Страуструпа
Глава 7 Лаптева
Обработка исключений
Производные исключений. Управление ресурсами. Конструкторы и деструкторы.
Стандартные исключения
Поддержка исключений в ANSI C
Безопасность исключений
Гарантии безопасности исключений STL

Сделать:


На самом деле, бросаться исключениями нельзя в конструкторе копирования исключения.
А если исключение возникло в выражении throw MakeSomeException(), где MakeSomeException() — 
конструктор или порождающая функция — никаких проблем.
Поэтому shared_ptr — хорошее решение:

struct my_exception
{
    shared_ptr<string> m_pStr;
public://''
    explicit my_exception(const string& str) : m_pStr(new string(str)) {}
    const string& what() const { return *m_pStr; }
};

Вопросы:


//exception 
// <- bad_alloc					new
// <- bad_cast					dynamic_cast
// <- bad_exception				спецификация исключения
// <- bad_typeid				typeid
// <- bad_ios_base::failure		ios_base::clear()
// <- logic_error				Логические ошибки
//		<- domain_error 
//		<- invalid_argument		bitset()
//		<- length_error		
//		<- out_of_range			at(), bitset<>::operator[]
// <- runtime_error				Ошибки времени выполнения
//		<- range_error 
//		<- overflow_error		bitset::to_ulong()
//		<- underflow_error


Советы:
1. Пользуйтесь исключениями в main(), в т.ч. catch(...)
2. Не пользуйтесь исключениями, когда достаточно локальных управляющих конструкций.
3. Пользуйтесь принципом "выделение ресурсов есть инициализация"
4. Генерируйте исключения для указания на ошибку в конструкторе
5. Не генерируйте исключения в деструкторах
6. В большом проекте наследуйте от общего класса исключений.
7. Гарантируйте освобождение каждого ресурса в конструкторе в случае исключения.
8. Пользуйтесь спецификацией исключения nothrow()
7. Библиотека не должна сама прекращать выполнение программы или выводить отладочную информацию.
8. Разрабатывайте стратегию обработки ошибок на ранних стадиях проектирования.
9. Пользуйтесь умными указателями
10.Конструкторы по умным указателям обычно объявляют explicit
11.auto_ptr реализует семантику владения (или деструктивного копирования)
12.Механизм SEH непереносим с платформы Win и не вызывает деструкторы при раскрутке стека
13.Если исключение бросается по ссылке, а ловится по значению, возможна срезка
14.Полным аналогом unexpected() является конструкция catch(...) в main() Можно кидать bad_exception из unexpected()
15.terminate() вызывается при вызове неперехваченного исключения. 
16.Стандартно вызывает abort() 
   Можно подменить вызов чтобы, например, вызвать exit(0) - он хотя бы вызовет деструкторы.
17.Контролируемый конструктор - перехватывает все исключения даже в списке инициализации ( и передает их далее )
18.Контролируемый метод перехватывает все исключения в себе
19.Если одно исключние кинет другое - программа упадет по terminate()
20.Пользуйтесь стандартными исключениями. Разделяйте те, которые кидает STL и которые должен кидать пользователь
21.Объем памяти гарантированно достаточен для исключения bad_alloc
   Исключения резервируют для себя память не в куче (возможно, на стеке)
22.Нельзя использовать в качестве элементов контейнера стандартный указатель auto_ptr,
   потому что операция копирования auto_ptr обнуляет исходный указатель
23.catch(...) обрабатывает все SE безусловно
24.Можно транслировать SE в С++ исключение установив _set_se_translator(). Программа должна быть скомпилирована с /EHa.
  (см. в файле structured_exception.h)
25.Если ссылка, по которой обрабатывается исключение неконстантна, теоретически можно модифицировать
   исключение перед проброской далее. Но так лучше не делать.
*  throw; гарантирует неизменность типа
*  catch(const void*) ловит вообще все исключения по указателю!
*  Обработка исключений замедляет программу. Простое использование try-catch замедляет на 5-10%
   Обработка замедляет на порядки. Поэтому исключения должны использоваться только для особых ситуаций
   и не быть элементом логики программы
* при приватном наследовании исключений по ссылке на базовый класс не ловится (нет what() и т.п.)
* uncaught_exception() reports that some exception is thrown and not processed yet

* In theory, you can throw exception of any type (int, bool, enum)
* don't throw exception while local error check is sufficient
* don't add to much nested catch-blocks, it will reduce performance dramatically
* members of exception class could be nothrow only
* If you catch bad_alloc, try to release memory rather than crash the application (TODO: example with nodes)
* inherit all exception from std::exception, so that they couldbe caught by the handler catch(std::exception & ex)
* some exceptions are not meant to be caught, they should not be better inherit from std::exception (ex. boost::thread)

Хорошая статья по IEEE FP format и исключениям
http://www.gamasutra.com/view/news/169203/Exceptional_floating_point.php

В C существует ограниченная поддержка псевдоисключений:
1. локальные переходы goto
2. нелокальные переходы setjmp, longjmp
3. Библиотека C также представляет унифицированный (хотя и примитивный)
пакет обработки событий, функции функции raise и signal (<signal.h>)
Обработчики могут взаимодействовать с внешним миром посредством объектов
типа sig_atomic_t
Вы свободны в выборе вызова функции abort, exit или longjmp 
из обработчика исключения, интерпретируя тем самым сигнал 
как завершающее исключение (terminating exception)
4. Если же вы предпочитаете метод опроса, то стандартная библиотека предоставляет
такой пример посредством объявлений в заголовочном файле <errno.h>. Этот
заголовок определяет errno плюс несколько величин, которые являются наиболее
популярными. Стандарт определяет три таких величины—EDOM, ERANGE и EILSEQ
для ошибок домена, диапазона и мультибайтового потока

Для каждого обработчика исключения компилятор генерирует уникально именованный дескриптор внутри
сегмента .data. Каждый дескриптор определяет закодированное (mangled) имя типа соответствующее типу
исключения обработчика.

Компилятор также генерирует ссылки на эти дескрипторы типов в сегменте xdata$x. Каждому типу ставится
в соответствие адрес обработчика, который перехватывает этот тип. Результирующее множество пар
дескриптор/обработчик формирует таблицу диспетчеризации, используемую библиотечным кодом обработки
исключений для перенаправления исключений.

В общем случае, компилятор генерирует одну преамбулу таблицы для функции, которая содержит блок try,
плюс одну запись в таблице для каждого обработчика в этом блоке try. К счастью, дескрипторы типов
разделяются между всеми таблицами диспетчеризации в программе. (Например, все обработчики
catch(long) в программе ссылаются на один и тот же дескриптор

Мораль: чтобы снизить накладные расходы обработки исключений на размер кода и данных вам необходимо
минимизировать количество функций перехватывающих исключения, количество обработчиков в этих
функциях и количество типов перехватываемых этими обработчиками.


Безопасность исключений, термин, который используется в стандарте C++ , однако, этот термин не определяет. 
Среди ценителей C++,  разные авторы используют этот термин для обозначения разных вещей.

1. Если объект перехватывает или возбуждает исключение, и все еще выполняет свои общедоступные 
(public) семантические гарантии, то такой объект обладает безопасностью интерфейса. В зависимости от 
силы семантических гарантий этот объект может не позволять исключению переходить к клиенту 
объекта. 
2. Если исключение не приводит к утечке ресурсов или неопределенному поведению, то объекту
присуща безопасность реализации. Безопасность реализации в общем случае легче всего обеспечить. К 
счастью, если вы делаете вашу реализацию безопасной, то зачастую вы обеспечиваете и безопасность 
сопутствующего интерфейса. 

Безопасность интерфейса подобна корректности модификатора const: прочный дизайн должен содержать его
с самого начала. Безопасность интерфейса нельзя привить впоследствии.

В частности, перехватив исключение в конструкторе и пытаясь создать объект заново
в действительности вы попытаетесь работать с совершенно другим объектом

Время жизни объекта начинается тогда, когда завершился его конструктор.
Следствие: Объект, чей конструктор не завершился, никогда не существовал.
Следствие: Единственный способ сообщить о неудачном конструировании состоит в выходе 
из конструктора посредством исключения.

Когда конструктор возбуждает исключение, то он убивает свой объект без вызова сопутствующего 
деструктора. Такое возбуждение исключения подвергает опасности безопасность реализации: если 
конструктор, который возбуждает исключение, распределяет ресурсы, то вы не можете рассчитывать на 
деструктор, чтобы освободить их (контролируемый конструктор, RAII)

Возможно делать конструктор nothrow(), а сложную инициализацию выносить в init()

Аргументы против init():
Использование тривиального конструктора + init() может быть источником проблем:
забыть вызвать init(), забыть, что init() бросает исключнеия, забыть проверить init()
Тривиальное состояние по умолчанию усложняет инвариант, т.к. нужно проверять на него
Постоянные if с циклами усложняют оптимизацию при компиляции
Безопасное состояние должно быть естественным инвариантом класса, а не артефактом реализации.


Если же вы решите возбуждать исключения, то вам придется понять всю их важность. Необходимо понять что 
ваши решения породят потенциально большое влияние на тех, кто будет использовать ваш код. Ваши
исключения являются часть вашего контракта интерфейса; вы должны полностью документировать какие 
исключения ваш интерфейс возбуждает, когда он их возбуждает и почему он возбуждает их. Необходимо 
рассмотреть необходимость надежного хранения этой документации в коде как части спецификации 
исключений.

Хорошим решением является включение имени файла и строки кода в ваши стандартные
исключения, применяемые в проекте.


Исключения предъявляют особые требования к шаблонам.
В частности, мы не можем быть уверены, что переданный тип T не бросает исключений
(особенно при конструкировании, передаче или возврату по значению)
Общих рекомендаций может быть несколько:
- передача тольео по ссылкам-указателям
- подавление исключений в catch(...)
- обертка в собственные исключения
- использование shared_pth (nothrow())
- прозрачность исключений в шаблонах (throw;)

То же самое относится к идиоме PImpl - в общем случае мы не можем знать, 
какие исключения бросает реализация, на которую мы ссылаемся.
Поэтому стоит быть готовым к любым исключениям

Приложение D

Стандартная библиотека имеет как гарантии безопасности исключений, так и требования
к элементам контейнера, совместимым контейнерам, итераторам, аллокаторам

Говорят, что операция exception-safe, когда она оставляет объект в консистентном состоянии
(или полностью и корректно его разрушает), иными словами, соблюдает инвариант

Виды гарантий безопасности STL
1. Основная (basic). Соблюдаются основные инварианты
2. Сильная (strong). Либо успех, либо откат операции
3. Отсутствия исключений (nothrow). Исключения не бросаются.

При написании своих библиотек, минимум это (1), где возможно - (2) и (3)

(1) и (2) зависят от реализации элементов контейнера (тоже должны быть консистентны)

Все контейнеры прозрачно пробрасывают пользовательские исключения из элементов,
чтобы пользователь мог узнать о проблеме
Обратно, при реализации высокоуровнего модуля, все исключения должны быть перехвачены внутри 
или обернуты в стандартные для модуля исключения

Бросок исключения между аллокацией и освобождением ресурса нарушает инвариант.

RAII предпочтительнее широкого использования try-блоков

При реализации библиотечных функций нужно анализировать каждую строку кода
на возможность появления исключений и их последствий, и описывать предоставленную
гарантию в документации к API

При этом не стоит усложнять - часто попытки сделать код "побезопаснее" усложняют инвариант

Ленивая инициализация в стандартных контейнерах часто ведет к издержкам

Гарантии контейнеров STL - см Страус спец. издание стр.1040
Пости все поддерживают сильную гарантия, за исключением:
- вставки в середину вектора
- вставки нескольких элементов в map
- операции со строками
- алгоритмы кроме uninitialized* (uninitialized* предлагают сильную)


Требования к элементам контейнера и пользовательским функциям:
- <>, == != swap не оставляют элемент в неконсистентном состоянии
- swap не должен генерировать исключений
- копирование и присвоение итераторов не должно кидать исключений
- алгоритмы uninitialized* требуют, чтобы ++ и -- итераторов не кидали исключнеия
- предикаты не должны генерировать исключений
- char_traits не должны кидать исключений
- локали и фасеты не должны генерировать исключений
- алгоритмы не генерируют исключений
- некоторые альгоритмы сортировки допускают генерацию искличений
- библиотека C не генерирует исключений, кроме функций qsort() и bsearch() - 
  им передаются указатели на функции, которые могут кидать исключения
- контейнеры указателей на аллоцированную память небезопасны
- предикаты для ассоциативных контейнеров должны копироваться
- конструктор должен устанавливать инвариант

Советы по реализации элементов контейнера:
- не уничтожать старое представление, пока не создано новое
- RAII
- перед генерацией исключения проверить консистентность (кроме конструкторов)

	//catch(...) нежелателен, т.к.:
	//1. он без повторного бросания не в состоянии вывести конкретное сообщение об ошибке.
	//2. В зависимости от опций компиляции он может ловить SEH исключения, которые ловить не следует.
	//3. он может ловить исключения, которые не должны ловиться пользовательским кодом 
	// (boost::tread_interrupted, преднамеренно не наследник std::exception).
	//4. он может поймать исключение, которое брошено по указателю и требует освобождения, 
	// но без повторного бросания не сможет его освободить.


