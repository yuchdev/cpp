Глава 15 Страуструпа
Глава 10 Лаптева
Иерархии классов. Множественное наследование.
Разрешение неоднозначности. using-объявления.
Виртуальное наследование. Виртуальные базовые классы.
Управление доступом. Защищенные члены. Доступ к базовым классам.
Полиморфизм, динамическое приведение, информация о типе и RTTI
"Виртуальные конструкторы"
Мультиметоды. Паттерн Посетитель.
Указатели на члены.
Свободная память. Виртуальные конструкторы.

Сделать:

Советы:
1. Пользуйтесь множественным наследованием, чтобы отделить реализацию от интерфейса.
2. Избегайте явного преобразвания типа
3. Если класс определяет operator delete, необходимо определить виртуальный деструктор
4. Не вызывайте виртуальные функции из конструкторов и деструкторов (подставляются только "свои" функции)
5. Разрешайте неоднозначность при множественном наследовании (явное переопределение или using).
6. Неоднозначность можно разрешить с помощью префикса ::
7. При виртуальном наследовании конструктор базового класса вызывается последеним производным классом в иерархии.
8. Множественное наследование хорошо управлемо в случае абстрактного базового класса
9. Объявление данных защищенными свидетельствует об ошибке проектирования. Это не относится к защищенным функциям.
10.Принцип доминирования состоит в следующем:
   виртуальный метод print() унаследован от всех трех базовых классов 
   но выполнится только там, где он явно переопределен
   причем в самом "производном" классе из доступных
11.Конструкторы вызываются в порядке, прописаном при наследовании.
12.Можно использовать паттерн финализации наследования.
13.Для поввышающего или перекрестного dynamic_cast требует полиморфизма.
14.Если преобразование запрещено, то возвращается 0-указатель.
15.Если преобразуется в ссылку, то при неудаче бросается исключение bad_cast.
16.Используйте мультиметоды по необходимости.
17.Интерфейс и реализация по умолчанию должны быть разделены 
  (т.е. реализация чисто виртуальной функции м.б. опасна, т.к. вызывается молча)
18.Когда функция невиртуальна, предполагается, что она не будет переопределена
19.Нормально оставлять виртуальную функцию в производных классах без реализации
20.В ряде случаев логично применять dynamic_cast с проверкой на 0
21.Мейерс 1-41 Эмпирическое правило выбора между шаблоном и полиморфизмом
   Полиморфизм - когда отличается поведение. Шаблон - когда отличается хранимый тип
22.Cтандарт не специфицирует vtbl, но по сути этим занимается конструктор в качестве первого шага, 
   так как указатель на vtbl — это просто скрытый член, который надо проинициализировать.
23.В vtable хранятся адреса виртуальных функций. 
   Еще может быть RTTI info - оно хранится по смещению 0 в vtbl. 
   И нетривиальное - при множественном наследовании сдвиги от this до области класса, которому принадлежит функция
*  сама таблица хранится в статической памяти. Есть разные подходы ее размещения в объектных файлах
   - копия в каждом obj
   - эвристика, обеспечивающая генерацию в первом использующем obj
*  изменение модификатора доступа класса не меняет логики програмы! 
   Поэтому даже закрытые члены участвуют в неоднозначностях
*  не используйте массивы полиморфных классов (т.е. не указателей) - Мейерс 2-3
*  вызов виртуальной функции на низком уровне выглядит как (*class->vptr[i])(class)
*  при множественном наследовании объект содержит несколько vptr (см. схему в ch_15)
* Member pointer could be treated os an OFFSET from the class beginning (or its polymorph part)
* pointers to method - not a pointers! Pointer template partial spec does not recogrize them

Указатель на нестатическую функцию-член класса — это особая статья, 
его нельзя присвоить простому указателю на данные или на функцию (м.б. разного размера), 
т.к. кроме самого указателя на функцию может содержать информацию о приведении this 
(особенно в случае множественного наследования), если функция-член приводится к другому типу
Кроме того, если функция виртуальная, вместо адреса хранится NULL, а также хранится индекс виртуальной функции.
Таким образом, для хранения указателя на функцию используется структура (не определена стандартом, но используется чаще всего)
- адрес функции или NULL, если виртуальная
- коррекция указателя this
- индекс, если функция виртуальная




http://blogs.msdn.com/b/oldnewthing/archive/2004/02/09/70002.aspx
http://www.codeproject.com/Articles/7150/Member-Function-Pointers-and-the-Fastest-Possible

// Borland, also used by Watcom
struct BorlandMFP { 
   CODEPTR m_func_address;
   int delta;
   int vindex; // or 0 if no virtual inheritance
};
if (vindex==0) adjustedthis = this + delta; 
else adjustedthis = *(this + vindex -1) + delta
CALL funcadr

// GNU g++ uses a tricky space optimisation, also adopted by IBM's VisualAge and XLC.
struct GnuMFP {
   union {
     CODEPTR funcadr; // always even
     int vtable_index_2; //  = vindex*2+1, always odd
   };
   int delta;
};
adjustedthis = this + delta
if (funcadr & 1) CALL (* ( *delta + (vindex+1)/2) + 4)
else CALL funcadr

// Microsoft and Intel use this for the 'Unknown' case.
// Microsoft also use it when the /vmg option is used
// In VC1.5 - VC6, this structure is broken! See below. 
struct MicrosoftUnknownMFP{
   FunctionPointer m_func_address; // 64 bits for Itanium.
   int m_delta;
   int m_vtordisp;
   int m_vtable_index; // or 0 if no virtual inheritance
};
 if (vindex=0) adjustedthis = this + delta
 else adjustedthis = this + delta + vtordisp + *(*(this + vtordisp) + vindex)
 CALL funcadr